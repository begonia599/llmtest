# LLM 网关基准测试结果

## 服务器配置
- **服务器 A（压测端）**: 8C/16G — mock-llm + k6
- **服务器 B（网关端）**: 4C/8G — 被测网关

---

## 第一轮：50 VUs / 20 凭证 / 60s

### 性能指标（k6 采集）

| 指标 | Go | Node.js | Next.js |
|------|---:|--------:|--------:|
| 每秒请求数 (RPS) | 6.69 | 6.72 | 6.82 |
| 总请求数 | 511 | 494 | 516 |
| 平均延迟 (ms) | 6300.64 | 6569.07 | 6281.57 |
| P50 延迟 (ms) | 6432.08 | 6961.11 | 6803.99 |
| P95 延迟 (ms) | 14669.36 | 14977.09 | 14714.86 |
| 成功率 (%) | 100.00 | 100.00 | 100.00 |
| SSE 数据块总数 | 46479 | 47155 | 46895 |

### 资源消耗（服务器 B — 网关进程）

| 指标 | Go | Node.js | Next.js |
|------|---:|--------:|--------:|
| 空闲 CPU (%) | 3.8-4.0 | 0.1 | 0.3-0.4 |
| 峰值 CPU (%) | 5.6 | 5.5 | 8.8 |
| 空闲内存 (MB) | 48 | 57.92 | 85.01 |
| 峰值内存 (MB) | 107 | 118.81 | 158.98 |
| GC 回收后内存 (MB) | 47 | 79.75 | 107.58 |
| 峰值文件描述符 | 110 | 123 | 123 |
| 线程数 | 7 | 11 | 11 |

---

## 第二轮：1000 VUs / 500 凭证 / 120s

### 性能指标（k6 采集）

| 指标 | Go | Node.js | Next.js |
|------|---:|--------:|--------:|
| 每秒请求数 (RPS) | **138.56** | 79.05 | * |
| 总请求数 | **19344** | 10982 | * |
| 平均延迟 (ms) | **6466.62** | 11317.55 | * |
| P50 延迟 (ms) | **6659.31** | 8507.56 | * |
| P95 延迟 (ms) | **15140.44** | 21324.29 | * |
| 成功率 (%) | **100.00** | 98.22 | * |
| SSE 数据块总数 | 1809964 | 1014726 | * |

> *Next.js 未输出 k6 汇总数据，可能因压力过大提前失败

### 资源消耗与效率（服务器 B — 4C/8G 网关进程）

| 指标 | Go | Node.js | Next.js |
|------|---:|--------:|--------:|
| 峰值 CPU - 服务器总量 (%) | 26.75 | 22.58 | 25.00 |
| 峰值 CPU - 单核占用 (%) | 107 | 90.3 | 100 |
| 峰值内存 (MB) | 1795.85 | 383.78 | 746.68 |
| 峰值文件描述符 | 2016 | 2054 | 1454 |
| 线程数 | 9 | 11 | 11 |
| **每 1% 服务器 CPU 产出 RPS** | **5.18** | 3.50 | * |
| **每 MB 内存产出 RPS** | 0.077 | **0.206** | * |

> 服务器 CPU = 单核占用 / 4核，即 400% 满载对应 100% 服务器利用率

### 第二轮分析

**Go 是唯一能真正扛住 1000 并发的网关**：
- RPS 是 Node.js 的 **1.75 倍**（138 vs 79）
- 成功率 **100%** vs Node.js 98.22%（Node.js 开始丢请求）
- Next.js 压力过大，k6 汇总数据未能正常输出

**CPU 利用效率**：
- Go 服务器 CPU 26.75%，产出 138 RPS → 每 1% CPU 产出 **5.18 RPS**
- Node.js 服务器 CPU 22.58%，产出 79 RPS → 每 1% CPU 产出 **3.50 RPS**
- **Go 的 CPU 效率是 Node.js 的 1.48 倍**

**为什么 Go 用了更多 CPU 反而是优势**：
- Go 能利用多核（单核占用 107% = 跨核并行），Node.js 单线程只能打满 1 个核
- 即使 Go 只多用了 4% 的服务器 CPU（26.75% vs 22.58%），吞吐量却高出 75%
- Node.js 的 3 个核闲置着，无法被利用

**内存使用**：
- Go 内存高（1795 MB）是因为 goroutine 并行维持大量活跃连接
- Node.js 内存低（383 MB）是因为请求在事件队列中排队串行处理
- Next.js 框架层额外消耗了 363 MB（746 vs 383）

**核心结论**：
- **同样的 4C/8G 服务器**：Go 能稳定服务 1000 并发用户（100% 成功），Node.js 已经开始丢请求
- **Go 天然利用多核**，Node.js 需要 cluster 模式才能利用多核，增加架构复杂度
- **Go 用约 1/4 的服务器 CPU 就处理了比 Node.js 多 75% 的请求**
